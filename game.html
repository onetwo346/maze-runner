<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Maze Runner - Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffcc;
            text-shadow: 0 0 5px #00ffcc;
            font-size: 1.2em;
            z-index: 1;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
</head>
<body>
    <div id="controls">WASD/Arrows or Swipe to move</div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        console.log('Script started');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        console.log('Renderer initialized');

        // Player
        const player = {
            x: 1,
            z: 1, // Switched 'y' to 'z' for 3D clarity (y is height)
            angle: 0,
            velocityX: 0,
            velocityZ: 0,
            speed: 0.15, // Faster for freer movement
            turnSpeed: 0.08 // Smoother turning
        };
        camera.position.set(player.x, 1.5, player.z);
        camera.rotation.order = 'YXZ';

        // Maze generation (10x10 grid)
        const mazeSize = 10;
        const maze = generateMaze(mazeSize, mazeSize);
        const wallHeight = 3;
        const wallGeometry = new THREE.BoxGeometry(1, wallHeight, 1);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.7 });
        const floorGeometry = new THREE.PlaneGeometry(mazeSize * 2, mazeSize * 2);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x1a0b3d, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;
        floor.position.y = -0.5;
        scene.add(floor);
        console.log('Floor added');

        // Build maze walls
        const walls = [];
        for (let x = 0; x < mazeSize; x++) {
            for (let z = 0; z < mazeSize; z++) {
                if (maze[x][z] === 1) {
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x, wallHeight / 2, z);
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }
        console.log('Walls added:', walls.length);

        // Core Exit
        const exitGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const exitMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
        const exit = new THREE.Mesh(exitGeometry, exitMaterial);
        exit.position.set(mazeSize - 2, 0.5, mazeSize - 2);
        scene.add(exit);
        console.log('Exit added');

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        console.log('Lighting added');

        // Controls
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': case 'arrowup': moveForward = true; break;
                case 's': case 'arrowdown': moveBackward = true; break;
                case 'a': case 'arrowleft': moveLeft = true; break;
                case 'd': case 'arrowright': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': case 'arrowup': moveForward = false; break;
                case 's': case 'arrowdown': moveBackward = false; break;
                case 'a': case 'arrowleft': moveLeft = false; break;
                case 'd': case 'arrowright': moveRight = false; break;
            }
        });

        // Touch controls for iPhone
        let touchStartX = 0, touchStartY = 0, touchDeltaX = 0, touchDeltaY = 0;
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touchDeltaX = e.touches[0].clientX - touchStartX;
            touchDeltaY = e.touches[0].clientY - touchStartY;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        document.addEventListener('touchend', () => {
            touchDeltaX = 0;
            touchDeltaY = 0;
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        });

        // Maze generation
        function generateMaze(width, height) {
            const maze = Array(width).fill().map(() => Array(height).fill(1));
            function carve(x, z) {
                maze[x][z] = 0;
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                directions.sort(() => Math.random() - 0.5);
                for (let [dx, dz] of directions) {
                    const nx = x + dx, nz = z + dz;
                    if (nx >= 0 && nx < width && nz >= 0 && nz < height && maze[nx][nz] === 1) {
                        maze[x + dx / 2][z + dz / 2] = 0;
                        carve(nx, nz);
                    }
                }
            }
            carve(1, 1);
            return maze;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Smooth movement with velocity
            player.velocityX *= 0.9; // Friction for smooth stop
            player.velocityZ *= 0.9;

            if (moveForward) {
                player.velocityX += Math.sin(player.angle) * player.speed;
                player.velocityZ += Math.cos(player.angle) * player.speed;
            }
            if (moveBackward) {
                player.velocityX -= Math.sin(player.angle) * player.speed;
                player.velocityZ -= Math.cos(player.angle) * player.speed;
            }
            if (moveLeft) {
                player.velocityX -= Math.cos(player.angle) * player.speed; // Strafe left
                player.angle += player.turnSpeed;
            }
            if (moveRight) {
                player.velocityX += Math.cos(player.angle) * player.speed; // Strafe right
                player.angle -= player.turnSpeed;
            }

            // Touch input
            if (Math.abs(touchDeltaX) > 5) player.angle -= touchDeltaX * 0.008; // Faster turning
            if (touchDeltaY < -20) {
                player.velocityX += Math.sin(player.angle) * player.speed;
                player.velocityZ += Math.cos(player.angle) * player.speed;
            }
            if (touchDeltaY > 20) {
                player.velocityX -= Math.sin(player.angle) * player.speed;
                player.velocityZ -= Math.cos(player.angle) * player.speed;
            }
            if (Math.abs(touchDeltaX) > 10 && Math.abs(touchDeltaY) < 20) {
                player.velocityX += Math.cos(player.angle) * player.speed * (touchDeltaX > 0 ? 1 : -1); // Strafe
            }

            // Update position with looser collision
            const newX = player.x + player.velocityX;
            const newZ = player.z + player.velocityZ;
            if (!collides(newX, newZ, 0.3)) { // Smaller collision radius
                player.x = newX;
                player.z = newZ;
            } else {
                // Slide along walls
                if (!collides(newX, player.z, 0.3)) player.x = newX;
                if (!collides(player.x, newZ, 0.3)) player.z = newZ;
            }

            camera.position.set(player.x, 1.5, player.z);
            camera.rotation.y = player.angle;

            // Win condition
            if (Math.hypot(player.x - (mazeSize - 2), player.z - (mazeSize - 2)) < 0.5) {
                alert('You escaped the cosmic labyrinth!');
                window.location.reload();
            }

            renderer.render(scene, camera);
        }
        animate();

        // Collision detection with radius
        function collides(x, z, radius = 0.3) {
            const gridX = Math.floor(x);
            const gridZ = Math.floor(z);
            const offset = radius;
            return (
                gridX < 0 || gridX >= mazeSize || gridZ < 0 || gridZ >= mazeSize ||
                maze[gridX][gridZ] === 1 ||
                (x - gridX < offset && gridX > 0 && maze[gridX - 1][gridZ] === 1) ||
                (gridX + 1 - x < offset && gridX < mazeSize - 1 && maze[gridX + 1][gridZ] === 1) ||
                (z - gridZ < offset && gridZ > 0 && maze[gridX][gridZ - 1] === 1) ||
                (gridZ + 1 - z < offset && gridZ < mazeSize - 1 && maze[gridX][gridZ + 1] === 1)
            );
        }

        // Resize handler
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        console.log('Setup complete');
    </script>
</body>
</html>
